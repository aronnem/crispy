% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}

% Jupyter Notebook prompt colors
\definecolor{nbsphinxin}{HTML}{303F9F}
\definecolor{nbsphinxout}{HTML}{D84315}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}



\title{crispy Documentation}
\date{Mar 08, 2017}
\release{0.1.0}
\author{Maxime J. Rizzo}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This software is designed to simulate lenslet array-based Integral Field Spectrographs and their reduction process. This was developed within the context of NASA's WFIRST Coronagraph mission.


\part{IFS Simulator}
\label{index:welcome-to-crispy-s-documentation}\label{index:ifs-simulator}

\chapter{Introduction to crispy}
\label{Introduction:Introduction-to-crispy}\label{Introduction::doc}
This software is designed to simulate lenslet array-based Integral Field
Spectrographs and their reduction process. This was developed within the
context of NASA's WFIRST Coronagraph mission.

In this notebook we go straight to the point and illustrate how to use
the code. We require astropy, numpy. This notebook was written in a
Python 3.5 kernel but should be backward compatible with Python 2.7.


\section{Create a polychromatic flatfield}
\label{Introduction:Create-a-polychromatic-flatfield}

\subsection{Initialization}
\label{Introduction:Initialization}
First we need to load the various modules that we need. Since the
notebook can be located anywhere, we need to add the location of the
Python code to the path first.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [1]: }\PYG{k+kn}{import} \PYG{n+nn}{sys}
        \PYG{n}{codefolder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../code}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if} \PYG{n}{codefolder} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{p}{:} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
        \PYG{k+kn}{import} \PYG{n+nn}{tools}
        \PYG{k+kn}{import} \PYG{n+nn}{glob}
        \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
        \PYG{k+kn}{from} \PYG{n+nn}{tools.initLogger} \PYG{k+kn}{import} \PYG{n}{getLogger}
        \PYG{n}{log} \PYG{o}{=} \PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{main}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{OriginalVerbatim}

All the IFS parameters are contained within a Python class called
`Params'. This class is initialized using only the path the `code'
directory from the repo. In particular, the Params class stores all the
relevant paths. All parameters can be changed on the fly.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [2]: }\PYG{k+kn}{from} \PYG{n+nn}{params} \PYG{k+kn}{import} \PYG{n}{Params}
        \PYG{n}{par} \PYG{o}{=} \PYG{n}{Params}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
\end{OriginalVerbatim}

All the parameters are stored in this class. During the various steps of
the software, they are appended to a header file.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [3]: }\PYG{n}{par}\PYG{o}{.}\PYG{n}{hdr}
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[3]: }SIMPLE  =                    T / conforms to FITS standard
        BITPIX  =                    8 / array data type
        NAXIS   =                    0 / number of array dimensions
        EXTEND  =                    T
        COMMENT
        COMMENT ************************************************************
        COMMENT ********************** General parameters ******************
        COMMENT ************************************************************
        COMMENT
        NLENS   =                  108 / \PYGZsh{} lenslets across array
        PITCH   =             0.000174 / Lenslet pitch (meters)
        INTERLAC=                    2 / Interlacing
        PHILENS =    26.56505117707799 / Rotation angle of the lenslets (deg)
        PIXSIZE =              1.3E\PYGZhy{}05 / Pixel size (meters)
        LENSAMP =                  0.5 / Lenslet sampling (lam/D)
        LSAMPWAV=                600.0 / Lenslet sampling wavelength (nm)
        FWHM    =                    2 / FHWM of PSFLet at detector (pixels)
        FWHMLAM =                660.0 / Wavelength at which FWHM is defined (nm)
        NPIX    =                 1024 / Number of detector pixels
        DISPDIST=                    F / Use PISCES distortion/dispersion?
\end{OriginalVerbatim}


\subsection{Create the flatfield}
\label{Introduction:Create-the-flatfield}
Creating a flatfield is a function built into the unitTests module. In
this case, we will construct a cube of nlam wavelength slices, each
having 512x512 pixels of value 1. The standard

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [5]: }\PYG{k+kn}{from} \PYG{n+nn}{unitTests} \PYG{k+kn}{import} \PYG{n}{testCreateFlatfield}
        \PYG{n}{help}\PYG{p}{(}\PYG{n}{testCreateFlatfield}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
Help on function testCreateFlatfield in module unitTests:

testCreateFlatfield(par, pixsize=0.1, npix=512, pixval=1.0, outname='flatfield.fits')
    Creates a polychromatic flatfield

    Parameters
    ----------
    par :   Parameter instance
        Contains all IFS parameters
    pixsize:   float
       Pixel scale (lam/D)
    npix: int
        Each input frame has a pixel size npix x npix
    pixval: float
        Each input frame has a unform value pixval

\end{OriginalVerbatim}
This test function will create a polychromatic flatfield at the
wavelengths provided by the existing wavelength calibration. Those
wavelengths can be retrieved as follows.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [6]: }\PYG{k+kn}{from} \PYG{n+nn}{tools.reduction} \PYG{k+kn}{import} \PYG{n}{calculateWaveList}
        \PYG{n}{help}\PYG{p}{(}\PYG{n}{calculateWaveList}\PYG{p}{)}
        \PYG{n}{lam\PYGZus{}midpts}\PYG{p}{,}\PYG{n}{lam\PYGZus{}endpts} \PYG{o}{=} \PYG{n}{calculateWaveList}\PYG{p}{(}\PYG{n}{par}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{lam\PYGZus{}midpts}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
Help on function calculateWaveList in module tools.reduction:

calculateWaveList(par, lam_list=None)
    Computes the wavelength lists corresponding to the center and endpoints of each
    spectral bin. Wavelengths are separated by a constant value in log space. Number of
    wavelengths depends on spectral resolution.

    Parameters
    ----------
    par:        Parameter instance
            Contains all IFS parameters
    lam_list:   list of wavelengths
            Usually this is left to None. If so, we use the wavelengths used for wavelength
            calibration. Otherwise, we could decide to focus on a smaller/larger region of
            the spectrum to retrieve. The final processed cubes will have bins centered
            on lam_midpts

    Returns
    -------
    lam_midpts: list of floats
            Wavelengths at the midpoint of each bin
    lam_endpts: list of floats
            Wavelengths at the edges of each bin

crispy - INFO - Reduced cube will have 17 wavelength bins
[ 704.42954343  711.94828852  719.54728511  727.22738976  734.9894682
  742.83439535  750.76305552  758.77634242  766.87515933  775.06041915
  783.33304453  791.69396797  800.14413192  808.68448889  817.31600156
  826.03964288  834.85639619]
\end{OriginalVerbatim}
Now let's create our flatfield. By default it will be stored as
par.unitTestsOutput/flatfield.fits

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [7]: }\PYG{n}{testCreateFlatfield}\PYG{p}{(}\PYG{n}{par}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
crispy - INFO - Reduced cube will have 17 wavelength bins
crispy - INFO - The number of input pixels per lenslet is 6.390626
crispy - INFO - Using PSFlet gaussian approximation
crispy - INFO - Final detector pixel per PSFLet: 40.000000
crispy - INFO - Processing wavelength 0.704430 (0 out of 17)
crispy - INFO - Processing wavelength 0.711948 (1 out of 17)
crispy - INFO - Processing wavelength 0.719547 (2 out of 17)
crispy - INFO - Processing wavelength 0.727227 (3 out of 17)
crispy - INFO - Processing wavelength 0.734989 (4 out of 17)
crispy - INFO - Processing wavelength 0.742834 (5 out of 17)
crispy - INFO - Processing wavelength 0.750763 (6 out of 17)
crispy - INFO - Processing wavelength 0.758776 (7 out of 17)
crispy - INFO - Processing wavelength 0.766875 (8 out of 17)
crispy - INFO - Processing wavelength 0.775060 (9 out of 17)
crispy - INFO - Processing wavelength 0.783333 (10 out of 17)
crispy - INFO - Processing wavelength 0.791694 (11 out of 17)
crispy - INFO - Processing wavelength 0.800144 (12 out of 17)
crispy - INFO - Processing wavelength 0.808684 (13 out of 17)
crispy - INFO - Processing wavelength 0.817316 (14 out of 17)
crispy - INFO - Processing wavelength 0.826040 (15 out of 17)
crispy - INFO - Processing wavelength 0.834856 (16 out of 17)
crispy - INFO - Number of detector pixels per lenslet: 13.384615
crispy - INFO - Rebinning final detector. Image has dimensions 1024x1024
crispy - INFO - Done.
crispy - INFO - Performance: 25 seconds total
main - INFO - Writing data to ../../code/unitTestsOutputs/flatfield.fits
\end{OriginalVerbatim}

\subsection{Display results}
\label{Introduction:Display-results}
Depending on your version of Python you might see a bunch of
VisibleDeprecationWarning. We are working on fixing that. Let's see what
we got.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [8]: }\PYG{o}{\PYGZpc{}}\PYG{k}{pylab} inline \PYGZhy{}\PYGZhy{}no\PYGZhy{}import\PYGZhy{}all
        \PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image.origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lower}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image.interpolation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest}\PYG{l+s+s1}{\PYGZsq{}}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{OriginalVerbatim}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [9]: }\PYG{k+kn}{from} \PYG{n+nn}{tools.image} \PYG{k+kn}{import} \PYG{n}{Image}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Image}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{unitTestsOutputs}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/flatfield.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
main - INFO - Read data from HDU 1 of ../../code/unitTestsOutputs/flatfield.fits
\end{OriginalVerbatim}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[9]: }\PYGZlt{}matplotlib.colorbar.Colorbar at 0x105f1ab38\PYGZgt{}
\end{OriginalVerbatim}

\noindent\sphinxincludegraphics{{Introduction_21_2}.png}

A zoom-in version is visible here:

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [10]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{img} \PYG{o}{=} \PYG{n}{Image}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{unitTestsOutputs}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/flatfield.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}
         \PYG{n}{subsize} \PYG{o}{=} \PYG{l+m+mi}{50}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{[}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{subsize}\PYG{p}{:}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{subsize}\PYG{p}{,}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{subsize}\PYG{p}{:}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{subsize}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
main - INFO - Read data from HDU 1 of ../../code/unitTestsOutputs/flatfield.fits
\end{OriginalVerbatim}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[10]: }\PYGZlt{}matplotlib.colorbar.Colorbar at 0x11ac2b198\PYGZgt{}
\end{OriginalVerbatim}

\noindent\sphinxincludegraphics{{Introduction_23_2}.png}


\section{Simulate detector readout}
\label{Introduction:Simulate-detector-readout}
We have also some routines that can add noise to the detector. Assuming
that the input detector map is in photons per second, we can
`detectorify' this map by adding Poisson noise, read noise, CIC noise,
and dark current noise. In the future, we will also implement
Electron-multiplying noise and Traps.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [11]: }\PYG{k+kn}{from} \PYG{n+nn}{tools.image} \PYG{k+kn}{import} \PYG{n}{Image}
         \PYG{k+kn}{from} \PYG{n+nn}{tools.detector} \PYG{k+kn}{import} \PYG{n}{readDetector}\PYG{p}{,}\PYG{n}{averageDetectorReadout}
         \PYG{n}{flat} \PYG{o}{=} \PYG{n}{Image}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{par}\PYG{o}{.}\PYG{n}{unitTestsOutputs}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/flatfield.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{read}\PYG{o}{=}\PYG{n}{readDetector}\PYG{p}{(}\PYG{n}{par}\PYG{p}{,}\PYG{n}{flat}\PYG{p}{,}\PYG{n}{inttime}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{append\PYGZus{}header}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
         
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
main - INFO - Read data from HDU 1 of ../../code/unitTestsOutputs/flatfield.fits
\end{OriginalVerbatim}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [12]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{subsize} \PYG{o}{=} \PYG{l+m+mi}{15}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{read}\PYG{p}{[}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{subsize}\PYG{p}{:}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{subsize}\PYG{p}{,}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{subsize}\PYG{p}{:}\PYG{n}{par}\PYG{o}{.}\PYG{n}{npix}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{subsize}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[12]: }\PYGZlt{}matplotlib.colorbar.Colorbar at 0x11b0dfdd8\PYGZgt{}
\end{OriginalVerbatim}

\noindent\sphinxincludegraphics{{Introduction_27_1}.png}

Let's save the noisified frame to a new name. This is useful to show
since writing to FITS is a very common task.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [13]: }\PYG{n}{newImage} \PYG{o}{=} \PYG{n}{Image}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{read}\PYG{p}{,}\PYG{n}{header}\PYG{o}{=}\PYG{n}{par}\PYG{o}{.}\PYG{n}{hdr}\PYG{p}{)}
         \PYG{n}{newImage}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{unitTestsOutputs}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/flatfield\PYGZus{}noise.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{clobber}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
         
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
main - INFO - Writing data to ../../code/unitTestsOutputs/flatfield_noise.fits
\end{OriginalVerbatim}

\section{Reduction step}
\label{Introduction:Reduction-step}
The reduction step is straightforward, as long as the wavelength
calibration is good.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [14]: }\PYG{k+kn}{from} \PYG{n+nn}{IFS} \PYG{k+kn}{import} \PYG{n}{reduceIFSMap}
         \PYG{n}{cube} \PYG{o}{=} \PYG{n}{reduceIFSMap}\PYG{p}{(}\PYG{n}{par}\PYG{p}{,}\PYG{n}{par}\PYG{o}{.}\PYG{n}{unitTestsOutputs}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/flatfield\PYGZus{}noise.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
main - INFO - Read data from HDU 1 of ../../code/unitTestsOutputs/flatfield_noise.fits
crispy - INFO - Reduced cube will have 17 wavelength bins
main - INFO - Writing data to ../../code/SimResults/flatfield_noise_red_optext.fits
\end{OriginalVerbatim}
Now we can display the cube interactively, or look it up with DS9 (it is
located in par.exportDir)

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [15]: }\PYG{k+kn}{import} \PYG{n+nn}{ipywidgets}
         \PYG{k}{def} \PYG{n+nf}{plt\PYGZus{}ifs\PYGZus{}optext}\PYG{p}{(}\PYG{n}{wchan}\PYG{p}{)}\PYG{p}{:}
             \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{cube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{wchan}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,}
                        \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{3600}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gist\PYGZus{}heat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
             \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{ipywidgets}\PYG{o}{.}\PYG{n}{interact}\PYG{p}{(}\PYG{n}{plt\PYGZus{}ifs\PYGZus{}optext}\PYG{p}{,} \PYG{n}{wchan}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{cube}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
         
\end{OriginalVerbatim}

\noindent\sphinxincludegraphics{{Introduction_34_0}.png}

Let's look now at the header of the created file

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [16]: }\PYG{n}{cube}\PYG{o}{.}\PYG{n}{header}
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[16]: }SIMPLE  =                    T / conforms to FITS standard
         BITPIX  =                    8 / array data type
         NAXIS   =                    0 / number of array dimensions
         EXTEND  =                    T
         COMMENT
         COMMENT ************************************************************
         COMMENT ********************** General parameters ******************
         COMMENT ************************************************************
         COMMENT
         NLENS   =                  108 / \PYGZsh{} lenslets across array
         PITCH   =             0.000174 / Lenslet pitch (meters)
         INTERLAC=                    2 / Interlacing
         PHILENS =    26.56505117707799 / Rotation angle of the lenslets (deg)
         PIXSIZE =              1.3E\PYGZhy{}05 / Pixel size (meters)
         LENSAMP =                  0.5 / Lenslet sampling (lam/D)
         LSAMPWAV=                600.0 / Lenslet sampling wavelength (nm)
         FWHM    =                    2 / FHWM of PSFLet at detector (pixels)
         FWHMLAM =                660.0 / Wavelength at which FWHM is defined (nm)
         NPIX    =                 1024 / Number of detector pixels
         DISPDIST=                    F / Use PISCES distortion/dispersion?
         COMMENT
         COMMENT ************************************************************
         COMMENT ********************** IFS Simulation ******************
         COMMENT ************************************************************
         COMMENT
         SCALE   =    6.390626327764054 / Factor by which the input slice is rescaled
         COMMENT
         COMMENT ************************************************************
         COMMENT ********************** Innput info *************************
         COMMENT ************************************************************
         COMMENT
         INSLICES=                   17 / Number of wavelengths in input cube
         COMMENT
         COMMENT ************************************************************
         COMMENT ********************** Detector readout ********************
         COMMENT ************************************************************
         COMMENT
         RN      =                  0.2 / Read noise (electrons/read)
         CIC     =                0.001 / Clock\PYGZhy{}induced charge
         DARK    =                1E\PYGZhy{}05 / Dark current
         TRAPS   =                    F / Use traps? T/F
         INTTIME =                  100 / Integration time (s)
         COMMENT
         COMMENT ************************************************************
         COMMENT ********************** Cube Extraction *********************
         COMMENT ************************************************************
         COMMENT
         R       =                   50 / Spectral resolution of final cube
         CALDIR  = \PYGZsq{}wavecalR50\PYGZus{}770\PYGZsq{}     / Directory of wavelength solution
         CUBEMODE= \PYGZsq{}Optimal Extraction\PYGZsq{} / Method used to extract data cube
         LAM\PYGZus{}MIN =    704.4295434323802 / Minimum mid wavelength of extracted cube
         LAM\PYGZus{}MAX =    834.8563961903914 / Maximum mid wavelength of extracted cube
         DLOGLAM =  0.01061696327719375 / Log spacing of extracted wavelength bins
         NLAM    =                   17 / Number of extracted wavelengths
         SMOOTHED=                    F / Cube NOT smoothed over bad lenslets
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [17]: }\PYG{n}{log}\PYG{o}{.}\PYG{n}{shutdown}\PYG{p}{(}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{AttributeError}                            Traceback (most recent call last)
\textcolor{ansi-green}{<ipython-input-17-87f260106d49>} in \textcolor{ansi-cyan}{<module>}\textcolor{ansi-blue}{()}
\textcolor{ansi-green}{----> 1}\textcolor{ansi-red}{ }log\textcolor{ansi-blue}{.}shutdown\textcolor{ansi-blue}{(}\textcolor{ansi-blue}{)}

\textcolor{ansi-red}{AttributeError}: 'CharisLogger' object has no attribute 'shutdown'
\end{OriginalVerbatim}

\part{PISCES}
\label{index:pisces}

\chapter{PISCES wavelength calibration}
\label{PISCES_wavecal:PISCES-wavelength-calibration}\label{PISCES_wavecal::doc}
We have PISCES VARIA calibration sets. We will show how to process them
to build a new wavelength calibration

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [1]: }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
        \PYG{k+kn}{import} \PYG{n+nn}{glob}
        \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
        \PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
        \PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image.origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lower}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{rcParams}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image.interpolation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest}\PYG{l+s+s1}{\PYGZsq{}}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{OriginalVerbatim}
Import crispy-related stuff

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [2]: }\PYG{k+kn}{import} \PYG{n+nn}{sys}
        \PYG{n}{codefolder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../code}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if} \PYG{n}{codefolder} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{p}{:} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
        \PYG{k+kn}{import} \PYG{n+nn}{tools}
        \PYG{k+kn}{import} \PYG{n+nn}{logging} \PYG{k+kn}{as} \PYG{n+nn}{log}
        \PYG{k+kn}{from} \PYG{n+nn}{tools.initLogger} \PYG{k+kn}{import} \PYG{n}{getLogger}
        \PYG{n}{log} \PYG{o}{=} \PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{main}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k+kn}{from} \PYG{n+nn}{tools.image} \PYG{k+kn}{import} \PYG{n}{Image}
        \PYG{k+kn}{from} \PYG{n+nn}{PISCESparams} \PYG{k+kn}{import} \PYG{n}{Params}
        \PYG{n}{par} \PYG{o}{=} \PYG{n}{Params}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
\end{OriginalVerbatim}


\section{Import files and subtract darks}
\label{PISCES_wavecal:Import-files-and-subtract-darks}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [3]: }\PYG{n}{VARIA\PYGZus{}ON}\PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{wavecalDir}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IFS???nm.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{VARIA\PYGZus{}OFF}\PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{wavecalDir}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IFSdark???nm.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{par}\PYG{o}{.}\PYG{n}{lamlist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{par}\PYG{o}{.}\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{VARIA\PYGZus{}ON}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{img} \PYG{o}{=} \PYG{n}{Image}\PYG{p}{(}\PYG{n}{VARIA\PYGZus{}ON}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZhy{}} \PYG{n}{Image}\PYG{p}{(}\PYG{n}{VARIA\PYGZus{}OFF}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}
            \PYG{n}{par}\PYG{o}{.}\PYG{n}{lamlist} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{VARIA\PYGZus{}ON}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IFS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
            \PYG{n}{par}\PYG{o}{.}\PYG{n}{filelist} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{n}{par}\PYG{o}{.}\PYG{n}{wavecalDir}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{det}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{lamlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.fits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{n}{Image}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{img}\PYG{p}{)}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{filelist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS605nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark605nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det605.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS615nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark615nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det615.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS625nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark625nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det625.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS635nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark635nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det635.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS645nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark645nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det645.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS655nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark655nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det655.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS665nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark665nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det665.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS675nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark675nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det675.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS685nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark685nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det685.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS695nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark695nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det695.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS705nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark705nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det705.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS715nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark715nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det715.0.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFS725nm.fits
crispy - INFO - Read data from HDU 0 of ../../code/ReferenceFiles/Calibra_170306/IFSdark725nm.fits
crispy - INFO - Writing data to ../../code/ReferenceFiles/Calibra_170306/det725.0.fits
\end{OriginalVerbatim}
Image the last file

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [4]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{350}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gist\PYGZus{}heat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxout}{Out[4]: }\PYGZlt{}matplotlib.colorbar.Colorbar at 0x10f56e128\PYGZgt{}
\end{OriginalVerbatim}

\noindent\sphinxincludegraphics{{PISCES_wavecal_8_1}.png}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [5]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{par}\PYG{o}{.}\PYG{n}{lamlist}\PYG{p}{)}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
[605.0, 615.0, 625.0, 635.0, 645.0, 655.0, 665.0, 675.0, 685.0, 695.0, 705.0, 715.0, 725.0]
\end{OriginalVerbatim}

\section{Build wavelength calibration files}
\label{PISCES_wavecal:Build-wavelength-calibration-files}
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [6]: }\PYG{k+kn}{from} \PYG{n+nn}{tools.wavecal} \PYG{k+kn}{import} \PYG{n}{buildcalibrations}
        \PYG{n}{buildcalibrations}\PYG{p}{(}\PYG{n}{par}\PYG{p}{,}
                          \PYG{n}{genwavelengthsol}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Compute wavelength at the center of all pixels}
                          \PYG{n}{makehiresPSFlets}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} do NOT make high\PYGZhy{}resolution PSFLets unless we have extremely good SNR}
                          \PYG{n}{inspect}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} build inspection PNGs in par.wavecalDir}
\end{OriginalVerbatim}
% This comment is needed to force a line break for adjacent ANSI cells
\begin{OriginalVerbatim}[commandchars=\\\{\}]
crispy - INFO - Building calibration files, placing results in ../../code/ReferenceFiles/Calibra_170306/
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det605.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det605.0.fits
crispy - INFO - Initializing PSFlet location transformation coefficients
crispy - INFO - Performing initial optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det605.0.fits
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det605.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det615.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det615.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det625.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det625.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det635.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det635.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det645.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det645.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det655.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det655.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det665.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det665.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det675.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det675.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det685.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det685.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det695.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det695.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det705.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det705.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det715.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det715.0.fits
crispy - INFO - Read data from HDU 1 of ../../code/ReferenceFiles/Calibra_170306/det725.0.fits
crispy - INFO - Initializing transformation coefficients with previous values
crispy - INFO - Performing final optimization of PSFlet location transformation coefficients for frame ../../code/ReferenceFiles/Calibra_170306/det725.0.fits
crispy - INFO - Saving wavelength solution to ../../code/ReferenceFiles/Calibra_170306/lamsol.dat
crispy - INFO - Computing wavelength values at pixel centers
crispy - INFO - Saving wavelength calibration cube
crispy - INFO - Total time elapsed: 401 s
\end{OriginalVerbatim}
\noindent\sphinxincludegraphics{{PISCES_wavecal_11_1}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_2}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_3}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_4}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_5}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_6}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_7}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_8}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_9}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_10}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_11}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_12}.png}

\noindent\sphinxincludegraphics{{PISCES_wavecal_11_13}.png}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }
\end{OriginalVerbatim}


\chapter{PISCES Data Reduction}
\label{PISCES_Reduce:PISCES-Data-Reduction}\label{PISCES_Reduce::doc}
The data reduction pipeline for PISCES is kept as simple as possible for
easing integration with JPL's coronagraph control software. It requires
an existing wavelength calibration.

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [1]: }\PYG{k+kn}{import} \PYG{n+nn}{sys}
        \PYG{n}{codefolder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../code}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if} \PYG{n}{codefolder} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{p}{:} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
        \PYG{k+kn}{import} \PYG{n+nn}{tools}
        \PYG{k+kn}{from} \PYG{n+nn}{tools.initLogger} \PYG{k+kn}{import} \PYG{n}{getLogger}
        \PYG{n}{log} \PYG{o}{=} \PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{main}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k+kn}{from} \PYG{n+nn}{tools.image} \PYG{k+kn}{import} \PYG{n}{Image}
        \PYG{k+kn}{from} \PYG{n+nn}{PISCESparams} \PYG{k+kn}{import} \PYG{n}{Params}
        \PYG{n}{par} \PYG{o}{=} \PYG{n}{Params}\PYG{p}{(}\PYG{n}{codefolder}\PYG{p}{)}
\end{OriginalVerbatim}

This is simple: load the reduction function, and call it!

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\textcolor{nbsphinxin}{In [ ]: }\PYG{k+kn}{from} \PYG{n+nn}{IFS} \PYG{k+kn}{import} \PYG{n}{reduceIFSMap}
        \PYG{n}{reduced\PYGZus{}cube}\PYG{o}{=} \PYG{n}{reduceIFSMap}\PYG{p}{(}\PYG{n}{par}\PYG{p}{,}\PYG{n}{MY\PYGZus{}FILE\PYGZus{}NAME}\PYG{p}{)}
\end{OriginalVerbatim}

The files are exported in the folder par.exportDir. Look for the
introduction documentation page for more details.


\part{API}
\label{index:api}

\chapter{tools package}
\label{tools:tools-package}\label{tools::doc}

\section{Submodules}
\label{tools:submodules}

\section{tools.detector module}
\label{tools:tools-detector-module}\label{tools:module-tools.detector}\index{tools.detector (module)}\index{averageDetectorReadout() (in module tools.detector)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.detector.averageDetectorReadout}\pysiglinewithargsret{\sphinxcode{tools.detector.}\sphinxbfcode{averageDetectorReadout}}{\emph{par}, \emph{filelist}, \emph{detectorFolderOut}, \emph{suffix='detector'}, \emph{offaxis=None}}{}
Process a list of files and creates individual detector readouts
If we want only one file, we can just make a list of 1

\end{fulllineitems}

\index{readDetector() (in module tools.detector)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.detector.readDetector}\pysiglinewithargsret{\sphinxcode{tools.detector.}\sphinxbfcode{readDetector}}{\emph{par}, \emph{IFSimage}, \emph{inttime=100}, \emph{append\_header=False}}{}
Read noise, CIC, dark current; NO TRAPS
Input is IFSimage in average photons per second
Quantum efficiency considerations are already taken care of when
generating IFSimage images

\end{fulllineitems}

\index{rebinDetector() (in module tools.detector)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.detector.rebinDetector}\pysiglinewithargsret{\sphinxcode{tools.detector.}\sphinxbfcode{rebinDetector}}{\emph{par}, \emph{finalFrame}, \emph{clip=False}}{}
Rebins the dense detector map with the correct scaling while conserving flux.
This also works with non-integer ratios.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{finalFrame} : 2D ndarray
\begin{quote}

Dense detector map to be rebinned.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{detectorFrame} : 2D array
\begin{quote}

Return the detector frame with correct pixel scale.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.detutils module}
\label{tools:tools-detutils-module}\label{tools:module-tools.detutils}\index{tools.detutils (module)}\index{frebin() (in module tools.detutils)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.detutils.frebin}\pysiglinewithargsret{\sphinxcode{tools.detutils.}\sphinxbfcode{frebin}}{\emph{array}, \emph{shape}, \emph{total=True}}{}
Function that performs flux-conservative
rebinning of an array. Found at \url{https://github.com/benjaminpope/pysco/blob/master/frebin.py}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{array: ndarray}
\begin{quote}

Numpy array to be rebinned
\end{quote}

\textbf{shape: tuple}
\begin{quote}

(x,y) of new array size
total: Boolean
\begin{quote}

when True flux is conserved
\end{quote}
\end{quote}

\textbf{Returns}

\textbf{-------}
\begin{quote}

new\_array: new rebinned array with dimensions: shape
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{rebin() (in module tools.detutils)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.detutils.rebin}\pysiglinewithargsret{\sphinxcode{tools.detutils.}\sphinxbfcode{rebin}}{\emph{a}, \emph{shape}}{}
Resizes a 2d array by averaging or repeating elements, 
new dimensions must be integral factors of original dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{a} : array\_like
\begin{quote}

Input array.
\end{quote}

\textbf{new\_shape} : tuple of int
\begin{quote}

Shape of the output array (y, x)
\end{quote}

\item[{Returns}] \leavevmode
\textbf{rebinned\_array} : ndarray
\begin{quote}

If the new shape is smaller of the input array, the data are averaged, 
if the new shape is bigger array elements are repeated
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.image module}
\label{tools:tools-image-module}\label{tools:module-tools.image}\index{tools.image (module)}\index{Image (class in tools.image)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.image.Image}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{tools.image.}\sphinxbfcode{Image}}{\emph{filename='`}, \emph{data=None}, \emph{ivar=None}, \emph{header=None}, \emph{extraheader=None}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

Image is the basic class for images

self.data, self.ivar, and self.header should be numpy ndarrays, 
which can be read from and written to a fits file with the load 
and write methods.  If not ndarrays, they should be None.

Image may be initialized with the name of the raw file to read,
through a call to Image.load().
\index{load() (tools.image.Image method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.image.Image.load}\pysiglinewithargsret{\sphinxbfcode{load}}{\emph{outfilename}}{}
Read the first HDU with data from filename into self.data, and
HDU{[}0{]}.header into self.header.  If there is more than one HDU
with data, attempt to read the second HDU with data into
self.ivar.

\end{fulllineitems}

\index{write() (tools.image.Image method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.image.Image.write}\pysiglinewithargsret{\sphinxbfcode{write}}{\emph{outfilename}, \emph{clobber=True}}{}
Creates a primary HDU using self.data and self.header, and
attempts to write to outfilename.  If self.ivar is not None,
append self.ivar as a second HDU before writing to a file.       
clobber is provided as a keyword to fits.HDUList.writeto.

\end{fulllineitems}


\end{fulllineitems}

\index{log (in module tools.image)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.image.log}\pysigline{\sphinxcode{tools.image.}\sphinxbfcode{log}\sphinxstrong{ = \textless{}tools.initLogger.CharisLogger object\textgreater{}}}
most of this code is due to Tim Brandt

\end{fulllineitems}



\section{tools.imgtools module}
\label{tools:module-tools.imgtools}\label{tools:tools-imgtools-module}\index{tools.imgtools (module)}\index{bowtie() (in module tools.imgtools)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.imgtools.bowtie}\pysiglinewithargsret{\sphinxcode{tools.imgtools.}\sphinxbfcode{bowtie}}{\emph{image}, \emph{xc}, \emph{yc}, \emph{openingAngle}, \emph{clocking}, \emph{IWApix}, \emph{OWApix}, \emph{export='bowtie'}, \emph{twomasks=False}}{}
Creates one or two binary mask for a shaped pupil bowtie mask
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{image: 2D ndarray}
\begin{quote}

Image to which the mask needs to be applied
\end{quote}

\textbf{xc: int}
\begin{quote}

X coordinate of center of bowtie
\end{quote}

\textbf{yc: int}
\begin{quote}

Y coordinate of center of bowtie
\end{quote}

\textbf{openingAngle: float}
\begin{quote}

Angle in degrees representing the opening angle of the bowtie mask
\end{quote}

\textbf{clocking: float}
\begin{quote}

Angle of rotation of the mask in degrees
\end{quote}

\textbf{IWApix: float}
\begin{quote}

Radius in pixels corresponding to the inner working angle of the mask
\end{quote}

\textbf{OWApix: float}
\begin{quote}

Radius in pixels corresponding to the outer working angle of the mask
\end{quote}

\textbf{export: boolean}
\begin{quote}

Whether to export the bowtie or not
\end{quote}

\textbf{twomasks: boolean}
\begin{quote}

If True, returns two masks, one for each side of the bowtie
If False, returns one single mask
\end{quote}

\item[{Returns}] \leavevmode
mask: 2D ndarrays of int
\begin{quote}

Bowtie mask with 1 inside the mask, zero everywhere else.
\end{quote}

mask2: 2D ndarrays of int
\begin{quote}

If twomasks is True, mask and mask2 are the two sides of the bowtie.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_bad\_pix\_mask() (in module tools.imgtools)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.imgtools.gen_bad_pix_mask}\pysiglinewithargsret{\sphinxcode{tools.imgtools.}\sphinxbfcode{gen\_bad\_pix\_mask}}{\emph{image}, \emph{filsize=3}, \emph{threshold=5.0}, \emph{return\_smoothed\_image=False}}{}
Identify and mask bad pixels using median filter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{image: 2D ndarray}
\begin{quote}

Image to clean
\end{quote}

\textbf{filsize: int}
\begin{quote}

Size of median filter in pixels
\end{quote}

\textbf{threshold: float}
\begin{quote}

Threshold in terms of standard deviations
\end{quote}

\textbf{return\_smoothed\_image: boolean}

\item[{Returns}] \leavevmode
goodpix: 2D int ndarray
\begin{quote}

Good pixel mask. 1 where pixel is good
\end{quote}

image\_sm: 2D ndarray, if return\_smoothed\_image

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.initLogger module}
\label{tools:module-tools.initLogger}\label{tools:tools-initlogger-module}\index{tools.initLogger (module)}\index{CharisLogger (class in tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{tools.initLogger.}\sphinxbfcode{CharisLogger}}{\emph{name}, \emph{level=0}}{}
Bases: \href{https://docs.python.org/2/library/logging.html\#logging.Logger}{\sphinxcode{logging.Logger}}

This is the advanced logging object used throughout the CHARIS
Data Extraction Pipeline.  It inherits from the standard 
Python library `logging' and provides added features.
The default log level for the output file will be 1, ie ALL messages;
while the default for the screen will be INFO, and can be changed easily 
using the setStreamLevel(lvl) member function.

Initialize the logger with a name and an optional level.
\index{MAINCRITICAL (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.MAINCRITICAL}\pysigline{\sphinxbfcode{MAINCRITICAL}\sphinxstrong{ = 80}}
\end{fulllineitems}

\index{MAINDEBUG (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.MAINDEBUG}\pysigline{\sphinxbfcode{MAINDEBUG}\sphinxstrong{ = 60}}
\end{fulllineitems}

\index{MAINERROR (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.MAINERROR}\pysigline{\sphinxbfcode{MAINERROR}\sphinxstrong{ = 75}}
\end{fulllineitems}

\index{MAININFO (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.MAININFO}\pysigline{\sphinxbfcode{MAININFO}\sphinxstrong{ = 65}}
\end{fulllineitems}

\index{MAINWARNING (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.MAINWARNING}\pysigline{\sphinxbfcode{MAINWARNING}\sphinxstrong{ = 70}}
\end{fulllineitems}

\index{PRIMCRITICAL (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.PRIMCRITICAL}\pysigline{\sphinxbfcode{PRIMCRITICAL}\sphinxstrong{ = 55}}
\end{fulllineitems}

\index{PRIMDEBUG (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.PRIMDEBUG}\pysigline{\sphinxbfcode{PRIMDEBUG}\sphinxstrong{ = 35}}
\end{fulllineitems}

\index{PRIMERROR (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.PRIMERROR}\pysigline{\sphinxbfcode{PRIMERROR}\sphinxstrong{ = 49}}
\end{fulllineitems}

\index{PRIMINFO (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.PRIMINFO}\pysigline{\sphinxbfcode{PRIMINFO}\sphinxstrong{ = 39}}
\end{fulllineitems}

\index{PRIMWARNING (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.PRIMWARNING}\pysigline{\sphinxbfcode{PRIMWARNING}\sphinxstrong{ = 45}}
\end{fulllineitems}

\index{SUMMARY (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.SUMMARY}\pysigline{\sphinxbfcode{SUMMARY}\sphinxstrong{ = 5}}
\end{fulllineitems}

\index{TOOLCRITICAL (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.TOOLCRITICAL}\pysigline{\sphinxbfcode{TOOLCRITICAL}\sphinxstrong{ = 29}}
\end{fulllineitems}

\index{TOOLDEBUG (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.TOOLDEBUG}\pysigline{\sphinxbfcode{TOOLDEBUG}\sphinxstrong{ = 9}}
\end{fulllineitems}

\index{TOOLERROR (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.TOOLERROR}\pysigline{\sphinxbfcode{TOOLERROR}\sphinxstrong{ = 25}}
\end{fulllineitems}

\index{TOOLINFO (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.TOOLINFO}\pysigline{\sphinxbfcode{TOOLINFO}\sphinxstrong{ = 15}}
\end{fulllineitems}

\index{TOOLWARNING (tools.initLogger.CharisLogger attribute)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.TOOLWARNING}\pysigline{\sphinxbfcode{TOOLWARNING}\sphinxstrong{ = 19}}
\end{fulllineitems}

\index{maincritical() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.maincritical}\pysiglinewithargsret{\sphinxbfcode{maincritical}}{\emph{msg}, \emph{lvl=80}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{maindebug() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.maindebug}\pysiglinewithargsret{\sphinxbfcode{maindebug}}{\emph{msg}, \emph{lvl=60}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{mainerror() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.mainerror}\pysiglinewithargsret{\sphinxbfcode{mainerror}}{\emph{msg}, \emph{lvl=75}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{maininfo() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.maininfo}\pysiglinewithargsret{\sphinxbfcode{maininfo}}{\emph{msg}, \emph{lvl=65}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{mainwarning() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.mainwarning}\pysiglinewithargsret{\sphinxbfcode{mainwarning}}{\emph{msg}, \emph{lvl=70}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{primcritical() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.primcritical}\pysiglinewithargsret{\sphinxbfcode{primcritical}}{\emph{msg}, \emph{lvl=55}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{primdebug() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.primdebug}\pysiglinewithargsret{\sphinxbfcode{primdebug}}{\emph{msg}, \emph{lvl=35}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{primerror() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.primerror}\pysiglinewithargsret{\sphinxbfcode{primerror}}{\emph{msg}, \emph{lvl=49}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{priminfo() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.priminfo}\pysiglinewithargsret{\sphinxbfcode{priminfo}}{\emph{msg}, \emph{lvl=39}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{primwarning() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.primwarning}\pysiglinewithargsret{\sphinxbfcode{primwarning}}{\emph{msg}, \emph{lvl=45}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{setStreamLevel() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.setStreamLevel}\pysiglinewithargsret{\sphinxbfcode{setStreamLevel}}{\emph{lvl=20}}{}
Set/change the level for the stream handler for a logging object.
Any file handlers will be left alone.
All messages of a higher severity level than `lvl' will be printed 
to the screen.
\begin{description}
\item[{Args:    }] \leavevmode\begin{description}
\item[{lvl (int): The severity level of messages printed to the screen with }] \leavevmode
the stream handler, default = 20.

\end{description}

\end{description}

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\multicolumn{2}{|l|}{\relax \textsf{\relax 
Standard Levels
\unskip}\relax \unskip}\relax &\multicolumn{2}{l|}{\relax \textsf{\relax 
New Levels
\unskip}\relax \unskip}\relax \\
\hline\textsf{\relax 
Name
\unskip}\relax &\textsf{\relax 
Level
\unskip}\relax &\textsf{\relax 
Name
\unskip}\relax &\textsf{\relax 
Level
\unskip}\relax \\
\hline
CRITICAL
&
50
&
MAINCRITICAL
&
80
\\
\hline
ERROR
&
40
&
MAINERROR
&
75
\\
\hline
WARNING
&
30
&
MAINWARNING
&
70
\\
\hline
INFO
&
20
&
MAININFO
&
65
\\
\hline
DEBUG
&
10
&
MAINDEBUG
&
60
\\
\hline
NOTSET
&
0
&
PRIMCRITICAL
&
55
\\
\hline\multirow{10}{*}{\relax \unskip}\relax &\multirow{10}{*}{\relax \unskip}\relax &
PRIMERROR
&
49
\\
\cline{3-4}&&
PRIMWARNING
&
45
\\
\cline{3-4}&&
PRIMINFO
&
39
\\
\cline{3-4}&&
PRIMDEBUG
&
35
\\
\cline{3-4}&&
TOOLCRITICAL
&
29
\\
\cline{3-4}&&
TOOLERROR
&
25
\\
\cline{3-4}&&
TOOLWARNING
&
19
\\
\cline{3-4}&&
TOOLINFO
&
15
\\
\cline{3-4}&&
TOOLDEBUG
&
9
\\
\cline{3-4}&&
SUMMARY
&
5
\\
\hline\end{tabulary}


\end{fulllineitems}

\index{summary() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.summary}\pysiglinewithargsret{\sphinxbfcode{summary}}{\emph{msg}, \emph{lvl=5}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{toolcritical() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.toolcritical}\pysiglinewithargsret{\sphinxbfcode{toolcritical}}{\emph{msg}, \emph{lvl=29}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{tooldebug() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.tooldebug}\pysiglinewithargsret{\sphinxbfcode{tooldebug}}{\emph{msg}, \emph{lvl=9}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{toolerror() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.toolerror}\pysiglinewithargsret{\sphinxbfcode{toolerror}}{\emph{msg}, \emph{lvl=25}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{toolinfo() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.toolinfo}\pysiglinewithargsret{\sphinxbfcode{toolinfo}}{\emph{msg}, \emph{lvl=15}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}

\index{toolwarning() (tools.initLogger.CharisLogger method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.CharisLogger.toolwarning}\pysiglinewithargsret{\sphinxbfcode{toolwarning}}{\emph{msg}, \emph{lvl=19}, \emph{*args}, \emph{**kws}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{addFileHandler() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.addFileHandler}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{addFileHandler}}{\emph{log}, \emph{lvl=1}}{}
This function will add a file handler to a log with the provided level.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{log (CharisLogger object): A CharisLogger object that was freshly }] \leavevmode
instantiated.

\item[{lvl (int): The severity level of messages printed to the file with }] \leavevmode
the file handler, default = 1.

\end{description}

\end{description}

\end{fulllineitems}

\index{addFitsStyleHandler() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.addFitsStyleHandler}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{addFitsStyleHandler}}{\emph{log}}{}
This function will add a file handler with a string format ideal for 
directly loading into a FITS header.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{log (CharisLogger object): A CharisLogger object that was freshly }] \leavevmode
instantiated.

\end{description}

\end{description}

\end{fulllineitems}

\index{addStreamHandler() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.addStreamHandler}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{addStreamHandler}}{\emph{log}, \emph{lvl=20}}{}
This function will add a stream handler to a log with the provided level.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{log (CharisLogger object): A CharisLogger object that was freshly }] \leavevmode
instantiated.

\item[{lvl (int): The severity level of messages printed to the screen with }] \leavevmode
the stream handler, default = 20.

\end{description}

\end{description}

\end{fulllineitems}

\index{getLogger() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.getLogger}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{getLogger}}{\emph{name='generalLoggerName'}, \emph{lvl=20}, \emph{addFH=True}, \emph{addSH=True}}{}
This will either return the logging object already
instantiated, or instantiate a new one and return it.  
\textbf{Use this function to both create and return any logger} to avoid 
accidentally adding additional handlers by using the setUpLogger function 
instead.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{name (str): The name for the logging object and }] \leavevmode
name.log will be the output file written to disk.

\item[{lvl (int): The severity level of messages printed to the screen with }] \leavevmode
the stream handler, default = 20.

\item[{addFH (boolean): Add a file handler to this logger?  Default severity }] \leavevmode
level for it will be 1, and it will be named following
name+'.log'.  Default = True.

\item[{addSH (boolean): Add a stream handler to this logger? Severity set with }] \leavevmode
the lvl argument.  Default = True.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{log (CharisLogger object): A CharisLogger object that was either }] \leavevmode
freshly instantiated or determined to 
already exist, then returned.

\end{description}

\end{description}

\end{fulllineitems}

\index{initLogger() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.initLogger}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{initLogger}}{\emph{logfile}, \emph{levelConsole=20}, \emph{levelLogFile=10}}{}
\end{fulllineitems}

\index{logFileProcessInfo() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.logFileProcessInfo}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{logFileProcessInfo}}{\emph{log}}{}
\end{fulllineitems}

\index{logSystemInfo() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.logSystemInfo}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{logSystemInfo}}{\emph{log}}{}
A function to be called just after a logging object is instantiated 
for the DEP to load the log up with info about the computer it is 
being ran on and the software version.  This function utilizes the 
psutil and platform libraries, so they must be install for it to work.  
For clarity of the log, it is suggested to perform immediately after 
instantiation to put it at the top of the log file.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{log (Python logging object): logging object to have the system's }] \leavevmode
info summarized in.

\end{description}

\end{description}

The messages this prints to the log will look like:

\begin{DUlineblock}{0em}
\item[] System Information Summary:
\item[] OS type = Linux
\item[] OS Version = 3.9.10-100.fc17.x86\_64
\item[] Machine UserName = xxxxxx.astron.s.u-tokyo.ac.jp
\item[] Machine Processor Type = x86\_64
\item[] Number of cores = 8
\item[] Total RAM {[}GB{]} = 23.5403785706, \% used = 15.9
\item[] Python Version = `2.7.3'
\end{DUlineblock}

\end{fulllineitems}

\index{setUpLogger() (in module tools.initLogger)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.initLogger.setUpLogger}\pysiglinewithargsret{\sphinxcode{tools.initLogger.}\sphinxbfcode{setUpLogger}}{\emph{name='generalLoggerName'}, \emph{lvl=20}, \emph{addFH=True}, \emph{addSH=True}}{}
This function is utilized by getLogger to set up a new logging object.
It will have the default name `generalLoggerName' and stream handler level
of 20 unless redefined in the function call.  
NOTE:
If a file handler is added, it will have the lowest severity level by 
default (Currently no need for changing this setting, so it will stay 
this way for now).  Remember that any messages will be passed up to any 
parent loggers, so children do not always need their own file handler.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{name (str): The name for the logging object and }] \leavevmode
name.log will be the output file written to disk.

\item[{lvl (int): The severity level of messages printed to the screen with }] \leavevmode
the stream handler, default = 20.

\item[{addFH (boolean): Add a file handler to this logger?  Default severity }] \leavevmode
level for it will be 1, and it will be named following
name+'.log'.  Default = True.

\item[{addSH (boolean): Add a stream handler to this logger? Severity set with }] \leavevmode
the lvl argument.  Default = True.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{log (CharisLogger object): A CharisLogger object that was freshly }] \leavevmode
instantiated.

\end{description}

\end{description}

\end{fulllineitems}



\section{tools.inputScene module}
\label{tools:module-tools.inputScene}\label{tools:tools-inputscene-module}\index{tools.inputScene (module)}\index{calc\_contrast() (in module tools.inputScene)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.inputScene.calc_contrast}\pysiglinewithargsret{\sphinxcode{tools.inputScene.}\sphinxbfcode{calc\_contrast}}{\emph{wavelist}, \emph{star\_T=\textless{}Quantity 6000.0 K\textgreater{}}, \emph{planet\_type='Jupiter'}, \emph{abundance=1}, \emph{distance=5}, \emph{phase=90}, \emph{mean\_contrast=1e-08}, \emph{folder='/local/data/nicolaus2/mrizzo/haystacks/Cahoy\_et\_al\_2010\_Albedo\_Spectra/albedo\_spectra/'}}{}
Calculates the contrast curve for a list of wavelengths

\end{fulllineitems}

\index{convert\_krist\_cube() (in module tools.inputScene)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.inputScene.convert_krist_cube}\pysiglinewithargsret{\sphinxcode{tools.inputScene.}\sphinxbfcode{convert\_krist\_cube}}{\emph{cubeshape}, \emph{lamlist}, \emph{star\_T}, \emph{star\_Vmag}, \emph{tel\_area}}{}
This function calculates the number of photons per second
entering the WFIRST obscured aperture, given the star Vmag and its temperature
\begin{quote}

for each slice of the input cube
This only works with John Krist's cubes,
\end{quote}

\end{fulllineitems}



\section{tools.lenslet module}
\label{tools:module-tools.lenslet}\label{tools:tools-lenslet-module}\index{tools.lenslet (module)}\index{Lenslets() (in module tools.lenslet)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.lenslet.Lenslets}\pysiglinewithargsret{\sphinxcode{tools.lenslet.}\sphinxbfcode{Lenslets}}{\emph{par}, \emph{imageplane}, \emph{lam}, \emph{lensletplane}, \emph{allweights=None}, \emph{kernels=None}, \emph{locations=None}}{}
Function Lenslets

Creates the IFS map on a `dense' detector array where each pixel is smaller than the
final detector pixels by a factor par.pxperdetpix. Adds to lensletplane array to save
memory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameters instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{image} : 2D array
\begin{quote}

Image plane incident on lenslets.
\end{quote}

\textbf{lam} : float
\begin{quote}

Wavelength (microns)
\end{quote}

\textbf{lensletplane} : 2D array
\begin{quote}

Densified detector plane; the function updates this variable
\end{quote}

\textbf{allweights} : 3D array
\begin{quote}

Cube with weights for each kernel
\end{quote}

\textbf{kernels} : 3D array
\begin{quote}

Kernels at locations on the detector
\end{quote}

\textbf{locations} : 2D array
\begin{quote}

Locations where the kernels are sampled
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{processImagePlane() (in module tools.lenslet)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.lenslet.processImagePlane}\pysiglinewithargsret{\sphinxcode{tools.lenslet.}\sphinxbfcode{processImagePlane}}{\emph{par}, \emph{imagePlane}}{}
Function processImagePlane

Rotates an image or slice, and rebins in a flux-conservative way
on an array of lenslets, using the plate scale provided in par.pixperlenslet.
Each pixel represents the flux within a lenslet. Starts by padding the original
image to avoid cropping edges when rotating. This step necessarily involves an
interpolation, so one needs to be cautious.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameters instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{imagePlane} : Image instance containing 3D input cube
\begin{quote}

Input cube to IFS sim, first dimension of data is wavelength
\end{quote}

\item[{Returns}] \leavevmode
\textbf{imagePlaneRot} : 2D array
\begin{quote}

Rotated image plane on same sampling as original.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.locate\_psflets module}
\label{tools:tools-locate-psflets-module}\label{tools:module-tools.locate_psflets}\index{tools.locate\_psflets (module)}\index{PSFLets (class in tools.locate\_psflets)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{tools.locate\_psflets.}\sphinxbfcode{PSFLets}}{\emph{load=False}, \emph{infile=None}, \emph{infiledir='.'}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

Helper class to deal with the PSFLets on the detector. Does most of the heavy lifting
during the wavelength calibration step.

Initialize the class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{load: Boolean}
\begin{quote}

Whether to load an already-existing wavelength calibration file
\end{quote}

\textbf{infile: String}
\begin{quote}

If load is True, this is the name of the file
\end{quote}

\textbf{infiledir: String}
\begin{quote}

If load is True, this is the directory in which the file resides
\end{quote}

\end{description}\end{quote}
\index{geninterparray() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.geninterparray}\pysiglinewithargsret{\sphinxbfcode{geninterparray}}{\emph{lam}, \emph{allcoef}, \emph{order=3}}{}
Set up array to solve for best-fit polynomial fits to the
coefficients of the wavelength solution.  These will be used
to smooth/interpolate the wavelength solution, and
ultimately to compute its inverse.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lam: float}
\begin{quote}

Wavelength in nm
\end{quote}

\textbf{allcoef: list of lists floats}
\begin{quote}

Polynomial coefficients of wavelength solution
\end{quote}

\textbf{order: int}
\begin{quote}

Order of polynomial wavelength solution
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

Populates the attribute interp\_arr in PSFLet class

\end{fulllineitems}

\index{genpixsol() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.genpixsol}\pysiglinewithargsret{\sphinxbfcode{genpixsol}}{\emph{par}, \emph{lam}, \emph{allcoef}, \emph{order=3}, \emph{lam1=None}, \emph{lam2=None}}{}
Calculates the wavelength at the center of each pixel within a microspectrum
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lam: float}
\begin{quote}

Wavelength in nm
\end{quote}

\textbf{allcoef: list of floats}
\begin{quote}

List describing the polynomial coefficients that best fit the lenslets,
for all wavelengths
\end{quote}

\textbf{order: int}
\begin{quote}

Order of the polynomical fit
\end{quote}

\textbf{lam1: float}
\begin{quote}

Lowest wavelength in nm
\end{quote}

\textbf{lam2: float}
\begin{quote}

Highest wavelength in nm
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

This functions fills in most of the fields of the PSFLet class: the array
of xindx, yindx, nlam, lam\_indx and nlam\_max

\end{fulllineitems}

\index{loadpixsol() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.loadpixsol}\pysiglinewithargsret{\sphinxbfcode{loadpixsol}}{\emph{infile=None}, \emph{infiledir='./calibrations'}}{}
Loads existing wavelength calibration file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{infile: String}
\begin{quote}

Name of the file
\end{quote}

\textbf{infiledir: String}
\begin{quote}

Directory in which the file resides
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{monochrome\_coef() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.monochrome_coef}\pysiglinewithargsret{\sphinxbfcode{monochrome\_coef}}{\emph{lam}, \emph{alllam=None}, \emph{allcoef=None}, \emph{order=3}}{}
\end{fulllineitems}

\index{return\_locations() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.return_locations}\pysiglinewithargsret{\sphinxbfcode{return\_locations}}{\emph{lam}, \emph{allcoef}, \emph{xindx}, \emph{yindx}, \emph{order=3}}{}
Calculates the detector coordinates of lenslet located at \sphinxcode{xindx}, \sphinxcode{yindx}
for desired wavelength \sphinxcode{lam}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lam: float}
\begin{quote}

Wavelength in nm
\end{quote}

\textbf{allcoef: list of lists floats}
\begin{quote}

Polynomial coefficients of wavelength solution
\end{quote}

\textbf{xindx: int}
\begin{quote}

X index of lenslet in lenslet array
\end{quote}

\textbf{yindx: int}
\begin{quote}

Y index of lenslet in lenslet array
\end{quote}

\textbf{order: int}
\begin{quote}

Order of polynomial wavelength solution
\end{quote}

\item[{Returns}] \leavevmode
interp\_x: float
\begin{quote}

X coordinate on the detector
\end{quote}

interp\_y: float
\begin{quote}

Y coordinate on the detector
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{return\_locations\_short() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.return_locations_short}\pysiglinewithargsret{\sphinxbfcode{return\_locations\_short}}{\emph{coef}, \emph{xindx}, \emph{yindx}}{}
Returns the x,y detector location of a given lenslet for a given polynomial fit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{coef: lists floats}
\begin{quote}

Polynomial coefficients of fit for a single wavelength
\end{quote}

\textbf{xindx: int}
\begin{quote}

X index of lenslet in lenslet array
\end{quote}

\textbf{yindx: int}
\begin{quote}

Y index of lenslet in lenslet array
\end{quote}

\item[{Returns}] \leavevmode
interp\_x: float
\begin{quote}

X coordinate on the detector
\end{quote}

interp\_y: float
\begin{quote}

Y coordinate on the detector
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{return\_res() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.return_res}\pysiglinewithargsret{\sphinxbfcode{return\_res}}{\emph{lam}, \emph{allcoef}, \emph{xindx}, \emph{yindx}, \emph{order=3}, \emph{lam1=None}, \emph{lam2=None}}{}
Returns the spectral resolution and interpolated wavelength array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lam: float}
\begin{quote}

Wavelength in nm
\end{quote}

\textbf{allcoef: list of lists floats}
\begin{quote}

Polynomial coefficients of wavelength solution
\end{quote}

\textbf{xindx: int}
\begin{quote}

X index of lenslet in lenslet array
\end{quote}

\textbf{yindx: int}
\begin{quote}

Y index of lenslet in lenslet array
\end{quote}

\textbf{order: int}
\begin{quote}

Order of polynomial wavelength solution
\end{quote}

\textbf{lam1: float}
\begin{quote}

Shortest wavelength in nm
\end{quote}

\textbf{lam2: float}
\begin{quote}

Longest wavelength in nm
\end{quote}

\item[{Returns}] \leavevmode
interp\_lam: array
\begin{quote}

Array of wavelengths
\end{quote}

R: float
\begin{quote}

Effective spectral resolution
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{savepixsol() (tools.locate\_psflets.PSFLets method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.PSFLets.savepixsol}\pysiglinewithargsret{\sphinxbfcode{savepixsol}}{\emph{outdir='calibrations/'}}{}
Saves wavelength calibration file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{outdir: String}
\begin{quote}

Directory in which to put the file. The file is name PSFloc.fits and is a
multi-extension FITS file, each extension corresponding to:
0. the list of wavelengths at which the calibration is done
1. a 2D ndarray with the X position of all lenslets
2. a 2D ndarray with the Y position of all lenslets
3. a 2D ndarray with the number of valid wavelengths for a given lenslet (some wavelengths fall outside of the detector area)
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{corrval() (in module tools.locate\_psflets)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.corrval}\pysiglinewithargsret{\sphinxcode{tools.locate\_psflets.}\sphinxbfcode{corrval}}{\emph{coef}, \emph{x}, \emph{y}, \emph{filtered}, \emph{order}, \emph{trimfrac=0.1}}{}
Return the negative of the sum of the middle XX\% of the PSFlet
spot fluxes (disregarding those with the most and the least flux
to limit the impact of outliers).  Analogous to the trimmed mean.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{coef:     list of floats}
\begin{quote}

coefficients for polynomial transformation
\end{quote}

\textbf{x: ndarray}
\begin{quote}

coordinates of lenslets
\end{quote}

\textbf{y: ndarray}
\begin{quote}

coordinates of lenslets
\end{quote}

\textbf{filtered: ndarray}
\begin{quote}

image convolved with gaussian PSFlet
\end{quote}

\textbf{order: int}
\begin{quote}

order of the polynomial fit
\end{quote}

\textbf{trimfrac: float}
\begin{quote}

fraction of outliers (high \& low combined) to trim 
Default 0.1 (5\% trimmed on the high end, 5\% on the low end)
\end{quote}

\item[{Returns}] \leavevmode
score:    float
\begin{quote}

Negative sum of PSFlet fluxes, to be minimized
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{initcoef() (in module tools.locate\_psflets)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.initcoef}\pysiglinewithargsret{\sphinxcode{tools.locate\_psflets.}\sphinxbfcode{initcoef}}{\emph{order}, \emph{scale=15.02}, \emph{phi=2.0496941961364943}, \emph{x0=0}, \emph{y0=0}}{}
Create a set of coefficients including a rotation matrix plus zeros.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{order: int}
\begin{quote}

The polynomial order of the grid distortion
\end{quote}

\textbf{scale: float}
\begin{quote}

The linear separation in pixels of the PSFlets. Default 13.88.
\end{quote}

\textbf{phi:   float}
\begin{quote}

The pitch angle of the lenslets.  Default atan(2)
\end{quote}

\textbf{x0:    float}
\begin{quote}

x offset to apply to the central pixel. Default 0
\end{quote}

\textbf{y0:    float}
\begin{quote}

y offset to apply to the central pixel. Default 0
\end{quote}

\item[{Returns}] \leavevmode
coef: list of floats
\begin{quote}

A list of length (order+1)*(order+2) to be optimized.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

The list of coefficients has space for a polynomial fit of the
input order (i.e., for order 3, up to terms like x**3 and x**2*y,
but not x**3*y).  It is all zeros in the output apart from the 
rotation matrix given by scale and phi.

\end{fulllineitems}

\index{locatePSFlets() (in module tools.locate\_psflets)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.locatePSFlets}\pysiglinewithargsret{\sphinxcode{tools.locate\_psflets.}\sphinxbfcode{locatePSFlets}}{\emph{inImage}, \emph{polyorder=2}, \emph{sig=0.7}, \emph{coef=None}, \emph{trimfrac=0.1}, \emph{phi=2.0496941961364943}, \emph{scale=15.02}, \emph{nlens=108}}{}
function locatePSFlets takes an Image class, assumed to be a
monochromatic grid of spots with read noise and shot noise, and
returns the esimated positions of the spot centroids.  This is
designed to constrain the domain of the PSF-let fitting later in
the pipeline.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{imImage: Image class}
\begin{quote}

Assumed to be a monochromatic grid of spots
\end{quote}

\textbf{polyorder: float}
\begin{quote}

order of the polynomial coordinate transformation. Default 2.
\end{quote}

\textbf{sig: float}
\begin{quote}

standard deviation of convolving Gaussian used
for estimating the grid of centroids.  Should be close
to the true value for the PSF-let spots.  Default 0.7.
\end{quote}

\textbf{coef: list}
\begin{quote}

initial guess of the coefficients of polynomial
coordinate transformation
\end{quote}

\textbf{trimfrac: float}
\begin{quote}

fraction of lenslet outliers (high \& low
combined) to trim in the minimization.  Default 0.1
(5\% trimmed on the high end, 5\% on the low end)
\end{quote}

\item[{Returns}] \leavevmode
x: 2D ndarray
\begin{quote}

Estimated spot centroids in x.
\end{quote}

y: 2D ndarray
\begin{quote}

Estimated spot centroids in y.
\end{quote}

good:2D boolean ndarray
\begin{quote}

True for lenslets with spots inside the detector footprint
\end{quote}

coef: list of floats
\begin{quote}

List of best-fit polynomial coefficients
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

the coefficients, if not supplied, are initially set to the 
known pitch angle and scale.  A loop then does a quick check to find
reasonable offsets in x and y.  With all of the first-order polynomial
coefficients set, the optimizer refines these and the higher-order
coefficients.  This routine seems to be relatively robust down to
per-lenslet signal-to-noise ratios of order unity (or even a little 
less).

Important note: as of now (09/2015), the number of lenslets to grid
is hard-coded as 1/10 the dimensionality of the final array.  This is
sufficient to cover the detector for the fiducial lenslet spacing.

\end{fulllineitems}

\index{transform() (in module tools.locate\_psflets)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.locate_psflets.transform}\pysiglinewithargsret{\sphinxcode{tools.locate\_psflets.}\sphinxbfcode{transform}}{\emph{x}, \emph{y}, \emph{order}, \emph{coef}}{}
Apply the coefficients given to transform the coordinates using
a polynomial.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{x:     ndarray}
\begin{quote}

Rectilinear grid
\end{quote}

\textbf{y:     ndarray of floats}
\begin{quote}

Rectilinear grid
\end{quote}

\textbf{order: int}
\begin{quote}

Order of the polynomial fit
\end{quote}

\textbf{coef:  list of floats}
\begin{quote}

List of the coefficients.  Must match the length required by
order = (order+1)*(order+2)
\end{quote}

\item[{Returns}] \leavevmode
\_x:    ndarray
\begin{quote}

Transformed coordinates
\end{quote}

\_y:    ndarray
\begin{quote}

Transformed coordinates
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.par\_utils module}
\label{tools:tools-par-utils-module}\label{tools:module-tools.par_utils}\index{tools.par\_utils (module)}\index{Consumer (class in tools.par\_utils)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.par_utils.Consumer}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{tools.par\_utils.}\sphinxbfcode{Consumer}}{\emph{task\_queue}, \emph{result\_queue}}{}
Bases: \sphinxcode{multiprocessing.context.Process}
\index{run() (tools.par\_utils.Consumer method)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.par_utils.Consumer.run}\pysiglinewithargsret{\sphinxbfcode{run}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Task (class in tools.par\_utils)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.par_utils.Task}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{tools.par\_utils.}\sphinxbfcode{Task}}{\emph{index}, \emph{func}, \emph{args}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

\end{fulllineitems}



\section{tools.plotting module}
\label{tools:module-tools.plotting}\label{tools:tools-plotting-module}\index{tools.plotting (module)}\index{plotKernels() (in module tools.plotting)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.plotting.plotKernels}\pysiglinewithargsret{\sphinxcode{tools.plotting.}\sphinxbfcode{plotKernels}}{\emph{par}, \emph{kernels}, \emph{locations}, \emph{plot=False}}{}
Make plots of all the kernels

\end{fulllineitems}



\section{tools.postprocessing module}
\label{tools:tools-postprocessing-module}\label{tools:module-tools.postprocessing}\index{tools.postprocessing (module)}\index{process\_SPC\_IFS() (in module tools.postprocessing)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.postprocessing.process_SPC_IFS}\pysiglinewithargsret{\sphinxcode{tools.postprocessing.}\sphinxbfcode{process\_SPC\_IFS}}{\emph{par}, \emph{psf\_time\_series\_folder}, \emph{offaxis\_psf\_filename}, \emph{planet\_radius=\textless{}Quantity 71492000.0 m\textgreater{}}, \emph{mean\_contrast=1e-08}, \emph{ref\_star\_T=\textless{}Quantity 9377.0 K\textgreater{}}, \emph{ref\_star\_Vmag=2.37}, \emph{target\_star\_T=\textless{}Quantity 5887.0 K\textgreater{}}, \emph{target\_star\_Vmag=5.03}, \emph{lamc=770.0}, \emph{BW=0.18}, \emph{Nlam=45}, \emph{n\_ref\_star\_imgs=30}, \emph{tel\_pupil\_area=\textless{}Quantity 3.650265060424805 m2\textgreater{}}, \emph{outdir\_time\_series='OS5'}, \emph{outdir\_detector='OS5/OS5\_detector'}, \emph{outdir\_average='OS5/OS5\_average'}, \emph{process\_cubes=True}, \emph{process\_offaxis=True}, \emph{process\_detector=True}, \emph{take\_averages=True}}{}
Process SPC PSF cubes from J. Krist through the IFS

\end{fulllineitems}



\section{tools.reduction module}
\label{tools:tools-reduction-module}\label{tools:module-tools.reduction}\index{tools.reduction (module)}\index{GPImethod2() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.GPImethod2}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{GPImethod2}}{\emph{par}, \emph{name}, \emph{ifsimage}}{}
Basic cube reduction using an IFS image and a wavecal cube
Equivalent to method 2 in the IDL primitive `pisces\_assemble\_spectral\_datacube'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:    Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Name that will be given to final image, without fits extension
\end{quote}

\textbf{ifsimage: Image instance of IFS detector map, with optional inverse variance}

\item[{Returns}] \leavevmode
\textbf{cube} :  3D array
\begin{quote}

Return the reduced cube from the original IFS image
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{calculateWaveList() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.calculateWaveList}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{calculateWaveList}}{\emph{par}, \emph{lam\_list=None}}{}
Computes the wavelength lists corresponding to the center and endpoints of each
spectral bin. Wavelengths are separated by a constant value in log space. Number of
wavelengths depends on spectral resolution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:        Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{lam\_list:   list of wavelengths}
\begin{quote}

Usually this is left to None. If so, we use the wavelengths used for wavelength
calibration. Otherwise, we could decide to focus on a smaller/larger region of
the spectrum to retrieve. The final processed cubes will have bins centered
on lam\_midpts
\end{quote}

\item[{Returns}] \leavevmode
lam\_midpts: list of floats
\begin{quote}

Wavelengths at the midpoint of each bin
\end{quote}

lam\_endpts: list of floats
\begin{quote}

Wavelengths at the edges of each bin
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{densifiedSimpleReduction() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.densifiedSimpleReduction}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{densifiedSimpleReduction}}{\emph{par}, \emph{name}, \emph{ifsimage}, \emph{ratio=10.0}}{}
Use the same method as the `simple' method but interpolate the original IFS map over
a grid with finer sampling
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:    Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Name that will be given to final image, without fits extension
\end{quote}

\textbf{ifsimage: Image instance of IFS detector map, with optional inverse variance}

\textbf{ratio:  int}
\begin{quote}

Ratio by which the original image is densified.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{cube} :  3D array
\begin{quote}

Return the reduced cube from the original IFS image
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_cutout() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.fit_cutout}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{fit\_cutout}}{\emph{subim}, \emph{psflets}, \emph{mode='lstsq'}}{}
Fit a series of PSFlets to an image, recover the best-fit coefficients.
This is currently little more than a wrapper for np.linalg.lstsq, but 
could be more complex if/when we regularize the problem or adopt some
other approach.

Inputs:
1. subim:   2D nadarray, microspectrum to fit
2. psflets: 3D ndarray, first dimension is wavelength.  psflets{[}0{]}
\begin{quote}

must match the shape of subim.
\end{quote}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} \begin{description}
\item[{mode:    string, method to use.  Currently limited to lstsq (a }] \leavevmode
simple least-squares fit using linalg.lstsq), this can
be expanded to include an arbitrary approach.

\end{description}

\end{enumerate}

Returns:
1. coef:    the best-fit coefficients (i.e. the microspectrum).

Note: this routine may also return the covariance matrix in the future.
It will depend on the performance of the algorithms and whether/how we
implement regularization.

\end{fulllineitems}

\index{fitspec\_intpix() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.fitspec_intpix}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{fitspec\_intpix}}{\emph{par}, \emph{im}, \emph{PSFlet\_tool}, \emph{lamlist}, \emph{delt\_y=6}, \emph{flat=None}, \emph{smoothandmask=False}, \emph{mode='gaussvar'}}{}
Optimal extraction routine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{im:     Image instance}
\begin{quote}

IFS image to be processed.
\end{quote}

\textbf{PSFlet\_tool: PSFLet instance}
\begin{quote}

Inverse wavelength solution that is constructed during wavelength calibration
\end{quote}

\textbf{lamlist: list of floats}
\begin{quote}

List of wavelengths to which each microspectrum is interpolated.
\end{quote}

\textbf{delt\_y: int}
\begin{quote}

Width in pixels of each microspectrum in the cross-dispersion direction
\end{quote}

\textbf{flat:}
\begin{quote}

Whether a lenslet flatfield is used (not implemented yet)
\end{quote}

\textbf{smoothandmask: Boolean}
\begin{quote}

Whether to smooth and mask bad pixels
\end{quote}

\item[{Returns}] \leavevmode
image:  Image instance
\begin{quote}

Reduced cube in the image.data field
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{fitspec\_intpix\_np() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.fitspec_intpix_np}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{fitspec\_intpix\_np}}{\emph{par}, \emph{im}, \emph{PSFlet\_tool}, \emph{lamlist}, \emph{delt\_y=6}, \emph{smoothandmask=False}}{}
Original optimal extraction routine in Numpy from T. Brand
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{im:     Image instance}
\begin{quote}

IFS image to be processed.
\end{quote}

\textbf{PSFlet\_tool: PSFLet instance}
\begin{quote}

Inverse wavelength solution that is constructed during wavelength calibration
\end{quote}

\textbf{lamlist: list of floats}
\begin{quote}

List of wavelengths to which each microspectrum is interpolated.
\end{quote}

\textbf{delt\_y: int}
\begin{quote}

Width in pixels of each microspectrum in the cross-dispersion direction
\end{quote}

\item[{Returns}] \leavevmode
image:  Image instance
\begin{quote}

Reduced cube in the image.data field
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{fitspec\_intpix\_np\_old() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.fitspec_intpix_np_old}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{fitspec\_intpix\_np\_old}}{\emph{im}, \emph{PSFlet\_tool}, \emph{lam}, \emph{delt\_x=7}, \emph{header=SIMPLE  =                    T / conforms to FITS standard                       BITPIX  =                    8 / array data type                                 NAXIS   =                    0 / number of array dimensions                      EXTEND  =                    T}}{}
\end{fulllineitems}

\index{get\_cutout() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.get_cutout}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{get\_cutout}}{\emph{im}, \emph{x}, \emph{y}, \emph{psflets}, \emph{dy=3}}{}
Cut out a microspectrum for fitting.  Return the inputs to 
linalg.lstsq or to whatever regularization scheme we adopt.
Assumes that spectra are dispersed in the -y direction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{im: Image intance}
\begin{quote}

Image containing data to be fit
\end{quote}

\textbf{x: float}
\begin{quote}

List of x centroids for each microspectrum
\end{quote}

\textbf{y: float}
\begin{quote}

List of y centroids for each microspectrum
\end{quote}

\textbf{psflets: PSFLet instance}
\begin{quote}

Typically generated from polychrome step in wavelength calibration routine
\end{quote}

\textbf{dy: int}
\begin{quote}

vertical length to cut out, default 3.  This is the length to cut out in the
+/-y direction; the lengths cut out in the +x direction (beyond the shortest 
and longest wavelengths) are also dy.
\end{quote}

\item[{Returns}] \leavevmode
subim:  2D array
\begin{quote}

A flattened subimage to be fit
\end{quote}

psflet\_subarr: 2D ndarray
\begin{quote}

first dimension is wavelength, second dimension is spatial, and is the same 
shape as the flattened subimage.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

Both subim and psflet\_subarr are scaled by the inverse
standard deviation if it is given for the input Image.  This 
will make the fit chi2 and properly handle bad/masked pixels.

\end{fulllineitems}

\index{intOptimalExtract() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.intOptimalExtract}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{intOptimalExtract}}{\emph{par}, \emph{name}, \emph{IFSimage}}{}
Calls the optimal extraction routine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Path \& name of the output file
\end{quote}

\textbf{IFSimage: Image instance}
\begin{quote}

Image instance of input image. Can have a .ivar field for a variance map.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

A cube is also written at par.SimResults/name.fits

\end{fulllineitems}

\index{lstsqExtract() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.lstsqExtract}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{lstsqExtract}}{\emph{par}, \emph{name}, \emph{ifsimage}, \emph{ivar=False}}{}
Least squares extraction, inspired by T. Brandt and making use of some of his code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:    Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Name that will be given to final image, without fits extension
\end{quote}

\textbf{ifsimage: Image instance of IFS detector map, with optional inverse variance}

\item[{Returns}] \leavevmode
\textbf{cube} :  3D array
\begin{quote}

Return the reduced cube from the original IFS image
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{simpleReduction() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.simpleReduction}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{simpleReduction}}{\emph{par}, \emph{name}, \emph{ifsimage}}{}
Basic cube reduction using an IFS image and a wavecal cube
Equivalent to method 1 in the IDL primitive `pisces\_assemble\_spectral\_datacube'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:    Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Name that will be given to final image, without fits extension
\end{quote}

\textbf{ifsimage: Image instance of IFS detector map, with optional inverse variance}

\item[{Returns}] \leavevmode
\textbf{cube} :  3D array
\begin{quote}

Return the reduced cube from the original IFS image
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{testReduction() (in module tools.reduction)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.reduction.testReduction}\pysiglinewithargsret{\sphinxcode{tools.reduction.}\sphinxbfcode{testReduction}}{\emph{par}, \emph{name}, \emph{ifsimage}}{}
Scratch routine to test various things.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:    Parameter instance}
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{name: string}
\begin{quote}

Name that will be given to final image, without fits extension
\end{quote}

\textbf{ifsimage: Image instance of IFS detector map, with optional inverse variance}

\item[{Returns}] \leavevmode
\textbf{cube} :  3D array
\begin{quote}

Return the reduced cube from the original IFS image
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.rotate module}
\label{tools:tools-rotate-module}\label{tools:module-tools.rotate}\index{tools.rotate (module)}\index{Rotate() (in module tools.rotate)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.rotate.Rotate}\pysiglinewithargsret{\sphinxcode{tools.rotate.}\sphinxbfcode{Rotate}}{\emph{image}, \emph{phi}, \emph{clip=True}, \emph{order=1}}{}
Rotate the input image by phi about its center.  Do not resize the 
image, but pad with zeros.  Function originally from Tim Brandt
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{image} : 2D square array
\begin{quote}

Image to rotate
\end{quote}

\textbf{phi} : float
\begin{quote}

Rotation angle in radians
\end{quote}

\textbf{clip} :  boolean (optional)
\begin{quote}

Clip array by sqrt(2) to remove fill values?  Default True.
\end{quote}

\textbf{order} : integer (optional)
\begin{quote}

Order of interpolation when rotating. Default is 1.
\end{quote}

\item[{Returns}] \leavevmode
imageout: 2D array
\begin{quote}

Rotated image of the same shape as the input image, with zero-padding
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.spectrograph module}
\label{tools:tools-spectrograph-module}\label{tools:module-tools.spectrograph}\index{tools.spectrograph (module)}\index{createAllWeightsArray() (in module tools.spectrograph)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.spectrograph.createAllWeightsArray}\pysiglinewithargsret{\sphinxcode{tools.spectrograph.}\sphinxbfcode{createAllWeightsArray}}{\emph{par}, \emph{locations}}{}
Creates weights for bilinear interpolation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{locations} : 2D ndarray, Nx2
\begin{quote}

Array of normalized locations on the detector, .
\end{quote}

\item[{Returns}] \leavevmode
\textbf{detectorFrame} : 2D array
\begin{quote}

Return the detector frame with correct pixel scale.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{distort() (in module tools.spectrograph)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.spectrograph.distort}\pysiglinewithargsret{\sphinxcode{tools.spectrograph.}\sphinxbfcode{distort}}{\emph{fx}, \emph{fy}, \emph{lam}}{}
Apply the distortion and dispersion from pre-determined polynomial
This was estimated from Zemax by Qian Gong and Jorge Llop and needs to be revisited
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{fx,fy} :   float
\begin{quote}

Distance between a lenslet and the center of the detector in millimeter.
\end{quote}

\textbf{lam} : float
\begin{quote}

Wavelength in microns.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{x,y} : float
\begin{quote}

Distance from center of detector at which image from a lenslet falls in mm.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{loadKernels() (in module tools.spectrograph)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.spectrograph.loadKernels}\pysiglinewithargsret{\sphinxcode{tools.spectrograph.}\sphinxbfcode{loadKernels}}{\emph{par}, \emph{wavel}}{}
Loads the kernels that represent the PSFs at different locations on the detector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{wavel} : float
\begin{quote}

Wavelength at which the kernels are needed
\end{quote}

\item[{Returns}] \leavevmode
kernels: array of 2D arrays
\begin{quote}

Represents each 2D kernel at each location
\end{quote}

locations: Nx2 ndarray
\begin{quote}

Location coordinates in detector position ratio (0,0) is bottom left, (1,1) is
top right
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{selectKernel() (in module tools.spectrograph)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.spectrograph.selectKernel}\pysiglinewithargsret{\sphinxcode{tools.spectrograph.}\sphinxbfcode{selectKernel}}{\emph{par}, \emph{lam}, \emph{refWaveList}, \emph{kernelList}}{}
Select the correct kernel for the current wavlength
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{lam} : float
\begin{quote}

Wavelength at which we want the get the kernel, in microns
\end{quote}

\textbf{refWaveList} : list of floats
\begin{quote}

Wavelengths at which the kernels are defined
\end{quote}

\textbf{kernelList} : list of 3D ndarrays
\begin{quote}

List of the kernels cubes at the wavelengths above
\end{quote}

\item[{Returns}] \leavevmode
kernels: array of 2D arrays
\begin{quote}

Represents each 2D kernel at each location for that wavlength
\end{quote}

locations: Nx2 ndarray
\begin{quote}

Location coordinates in detector position ratio (0,0) is bottom left, (1,1) is
top right
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{tools.wavecal module}
\label{tools:tools-wavecal-module}\label{tools:module-tools.wavecal}\index{tools.wavecal (module)}\index{buildcalibrations() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.buildcalibrations}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{buildcalibrations}}{\emph{par}, \emph{filelist=None}, \emph{lamlist=None}, \emph{order=3}, \emph{inspect=True}, \emph{genwavelengthsol=True}, \emph{makehiresPSFlets=True}, \emph{savehiresimages=True}, \emph{borderpix=4}, \emph{upsample=3}, \emph{nsubarr=3}, \emph{parallel=True}}{}
Master wavelength calibration function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{filelist: list of strings}
\begin{quote}

List of the fits files that contain the monochromatic calibration files
\end{quote}

\textbf{lamlist: list of floats}
\begin{quote}

Wavelengths in nm at which the files are taken
\end{quote}

\textbf{order: int}
\begin{quote}

Order of the polynomial used to fit the PSFLet positions across the detector
\end{quote}

\textbf{genwavelengthsol: Boolean}
\begin{quote}

If True, generate the wavelength calibration. Creates a text file with all
polynomial coefficients that best fit the PSFLet positions at each wavelength.
If False, then load an already-generated file.
\end{quote}

\textbf{inspect: Boolean}
\begin{quote}

Whether or not to create PNG files that overlay PSFLet fitted position on the
monochromatic pictures, to visually inspect the fitting results
\end{quote}

\textbf{makehiresPSFlets: Boolean}
\begin{quote}

Whether or not to do a high-resolution fitting of the PSFs, using the sampling
diversity. This requires high-SNR monochromatic images.
\end{quote}

\textbf{savehiresimages: Boolean}
\begin{quote}

Whether to save fits files with the high-res PSFLets
\end{quote}

\textbf{borderpix:  int}
\begin{quote}

Number of pixels that are not taken into account towards the edges of the detector
\end{quote}

\textbf{upsample: int}
\begin{quote}

Upsampling factor for each high-resolution PSFLet
\end{quote}

\textbf{nsubarr: int}
\begin{quote}

Detector will be divided into nsubarr x nsubarr regions. A high-resolution PSFLet
will be determined in each region from the average of all PSFLets within that
region
\end{quote}

\textbf{parallel: Boolean}
\begin{quote}

Whether or not to parallelize the computation for the high-resolution PSFLet and
polychrome computation. The wavelength calibration step cannot be parallelized since
each wavelength uses the previous wavelength solution as a guess input.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

This function generates all the files required to process IFS cubes:
lamsol.dat: contains a list of the wavelengths and the polynomial coefficients that
\begin{quote}

describe the X,Y positions of all lenslets on the detector as a function 
of lenslet position on the lenslet array.
\end{quote}
\begin{description}
\item[{polychromekeyRXX.fits:  where XX is replaced by the spectral resolution defined in the}] \leavevmode
parameters file. This is a multi-extension fits file with: 
- a list of the central wavelengths at which the final cube will be reduced to
- an array of the X positions of all lenslets
- an array of the Y positions of all lenslets
- an array of booleans indicating whether that lenslet is good or not
(e.g. when it is outside of the detector area)

\item[{polychromeRXX.fits: list of 2D arrays of size Npix x Npix which each contain a map with}] \leavevmode
the high-resolution lenslet PSFLets put in their correct position
for all the wavelengths that we want in the output cube. Each PSFLet
in each wavelength slice is used for least-squares fitting.

\item[{PSFLoc.fits:    nsubarr x nsubarr array of 2D high-resolution PSFLets at each location}] \leavevmode
in the detector.

\end{description}

polychromeRXX.fits and PSFLoc.fits are only generated if makehiresPSFlets is True.

\end{fulllineitems}

\index{computeWavecal() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.computeWavecal}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{computeWavecal}}{\emph{par}, \emph{lamlist=None}, \emph{filelist=None}, \emph{order=3}}{}
Computes a wavelength calibration from a set of fits files
Uses Tim Brandt's locate\_PSFlets routine with an initial guess.
The consecutive solutions use information from previous solutions to improve the
initial guess.
The process can be optimized somewhat by reducing the number of lenslets within
the locatePSFlets function (could make this a parameter!)
lamlist and filelist can be defined in the parameters in which case they don't need to be set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par:        Parameter instance}

\textbf{lamlist:    list of floats}
\begin{quote}

Wavelengths in nm
\end{quote}

\textbf{filelist:   list of filenames}
\begin{quote}

List of fits files to open in corresponding order
\end{quote}

\textbf{order:      int}
\begin{quote}

Order of 2d polynomial to be fitted to lenslets
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

Obsolete now

\end{fulllineitems}

\index{createPolychrome() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.createPolychrome}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{createPolychrome}}{\emph{par}}{}
To be run after generating a wavelength calibration set.
This function constructs a cube of (lam\_max-lam\_min)/par.dlam depth,
in which each slice is a monochromatic map at that wavelength.
If the wavelength calibration doesn't contain all the required wavelengths,
interpolate between wavelengths using map\_coordinates.
In the end, one should be able to make a cutout at a given location and get a cube
with all the psflets for that lenslet.

For now, this only works with simulated, noiseless data in order to get
almost perfect PSFs. In practice, we will have to create this cube from data.
For now, already assumes that all wavelengths are available (need to compute these)

\end{fulllineitems}

\index{createWavecalFiles() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.createWavecalFiles}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{createWavecalFiles}}{\emph{par}, \emph{lamlist}}{}
Creates a set of monochromatic IFS images to be used in wavelength calibration step

\end{fulllineitems}

\index{do\_inspection() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.do_inspection}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{do\_inspection}}{\emph{par}, \emph{image}, \emph{xpos}, \emph{ypos}, \emph{lam}}{}
\end{fulllineitems}

\index{gethires() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.gethires}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{gethires}}{\emph{x}, \emph{y}, \emph{image}, \emph{upsample=5}, \emph{nsubarr=5}, \emph{npix=13}, \emph{renorm=True}}{}
Build high resolution images of the undersampled PSF using the
monochromatic frames.

Inputs:
1.

\end{fulllineitems}

\index{make\_polychrome() (in module tools.wavecal)}

\begin{fulllineitems}
\phantomsection\label{tools:tools.wavecal.make_polychrome}\pysiglinewithargsret{\sphinxcode{tools.wavecal.}\sphinxbfcode{make\_polychrome}}{\emph{lam1}, \emph{lam2}, \emph{hires\_arrs}, \emph{lam\_arr}, \emph{psftool}, \emph{allcoef}, \emph{xindx}, \emph{yindx}, \emph{ydim}, \emph{xdim}, \emph{upsample=5}, \emph{nlam=10}}{}
\end{fulllineitems}



\section{Module contents}
\label{tools:module-tools}\label{tools:module-contents}\index{tools (module)}

\chapter{unitTests module}
\label{unitTests:module-unitTests}\label{unitTests:unittests-module}\label{unitTests::doc}\label{unitTests:astropy}\index{unitTests (module)}\index{testCreateFlatfield() (in module unitTests)}

\begin{fulllineitems}
\phantomsection\label{unitTests:unitTests.testCreateFlatfield}\pysiglinewithargsret{\sphinxcode{unitTests.}\sphinxbfcode{testCreateFlatfield}}{\emph{par}, \emph{pixsize=0.1}, \emph{npix=512}, \emph{pixval=1.0}, \emph{outname='flatfield.fits'}}{}
Creates a polychromatic flatfield
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{par} :   Parameter instance
\begin{quote}

Contains all IFS parameters
\end{quote}

\textbf{pixsize:   float}
\begin{quote}

Pixel scale (lam/D)
\end{quote}

\textbf{npix: int}
\begin{quote}

Each input frame has a pixel size npix x npix
\end{quote}

\textbf{pixval: float}
\begin{quote}

Each input frame has a unform value pixval
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{testCutout() (in module unitTests)}

\begin{fulllineitems}
\phantomsection\label{unitTests:unitTests.testCutout}\pysiglinewithargsret{\sphinxcode{unitTests.}\sphinxbfcode{testCutout}}{\emph{par}, \emph{fname}, \emph{lensnum=0}}{}
Testing the cutout function

\end{fulllineitems}

\index{testFitCutout() (in module unitTests)}

\begin{fulllineitems}
\phantomsection\label{unitTests:unitTests.testFitCutout}\pysiglinewithargsret{\sphinxcode{unitTests.}\sphinxbfcode{testFitCutout}}{\emph{par}, \emph{fname}, \emph{lensnum}, \emph{mode='lstsq'}, \emph{ivar=False}}{}
Testing the fit\_cutout function

\end{fulllineitems}

\index{testGenPixSol() (in module unitTests)}

\begin{fulllineitems}
\phantomsection\label{unitTests:unitTests.testGenPixSol}\pysiglinewithargsret{\sphinxcode{unitTests.}\sphinxbfcode{testGenPixSol}}{\emph{par}}{}
\end{fulllineitems}

\index{testLoadKernels() (in module unitTests)}

\begin{fulllineitems}
\phantomsection\label{unitTests:unitTests.testLoadKernels}\pysiglinewithargsret{\sphinxcode{unitTests.}\sphinxbfcode{testLoadKernels}}{\emph{par}}{}
Make sure the kernel interpolation with wavelength makes sense

\end{fulllineitems}



\part{Indices and tables}
\label{index:indices-and-tables}\label{index:astropy}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{t}
\item {\texttt{tools}}, \pageref{tools:module-tools}
\item {\texttt{tools.detector}}, \pageref{tools:module-tools.detector}
\item {\texttt{tools.detutils}}, \pageref{tools:module-tools.detutils}
\item {\texttt{tools.image}}, \pageref{tools:module-tools.image}
\item {\texttt{tools.imgtools}}, \pageref{tools:module-tools.imgtools}
\item {\texttt{tools.initLogger}}, \pageref{tools:module-tools.initLogger}
\item {\texttt{tools.inputScene}}, \pageref{tools:module-tools.inputScene}
\item {\texttt{tools.lenslet}}, \pageref{tools:module-tools.lenslet}
\item {\texttt{tools.locate\_psflets}}, \pageref{tools:module-tools.locate_psflets}
\item {\texttt{tools.par\_utils}}, \pageref{tools:module-tools.par_utils}
\item {\texttt{tools.plotting}}, \pageref{tools:module-tools.plotting}
\item {\texttt{tools.postprocessing}}, \pageref{tools:module-tools.postprocessing}
\item {\texttt{tools.reduction}}, \pageref{tools:module-tools.reduction}
\item {\texttt{tools.rotate}}, \pageref{tools:module-tools.rotate}
\item {\texttt{tools.spectrograph}}, \pageref{tools:module-tools.spectrograph}
\item {\texttt{tools.wavecal}}, \pageref{tools:module-tools.wavecal}
\indexspace
\bigletter{u}
\item {\texttt{unitTests}}, \pageref{unitTests:module-unitTests}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
